#!/bin/bash

## Bash settings
set -uo pipefail

## Script globals
script_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$({ cd "$(dirname "${BASH_SOURCE[0]}")" || { echo "Failed to access script file directory" >&2; exit; } } && pwd)
script_dir_abs=$({ cd "$(dirname "${BASH_SOURCE[0]}")" || { echo "Failed to access script file directory" >&2; exit; } } && pwd -P)
script_file="${script_dir}/${script_name}"
if [ -L "${BASH_SOURCE[0]}" ]; then
    script_file_abs=$(readlink "${BASH_SOURCE[0]}")
else
    script_file_abs="${script_dir_abs}/${script_name}"
fi
export CURRENT_PARENT_BASH_SCRIPT_FILE="$script_file"
script_args=("$@")

## Script imports
lib_dir="${script_dir}/../lib"
bash_functions_script="${lib_dir}/bash_script_func.sh"

## Source imports
source "$bash_functions_script"


## Arguments
cleanup_mode_choices_arr=( 'pbs' 'ssh' )
cleanup_mode=''
use_ssh=false
ssh_passphrase=''
remove_all=false
ssh_dryrun=false
dryrun=false


## Script usage
read -r -d '' script_usage << EOM
Remove files from /local directory on cluster nodes
Usage: ${script_name} (pbs|ssh) [--all] [--dryrun] [--ssh-dryrun]
  pbs : submit single-core PBS job to every node on the cluster for cleanup
  ssh : SSH into every node on the cluster in serial and run cleanup command over SSH
  --ssh-pw : passPHRASE for all SSH connections (if not provided, may need to be entered for every node)
  --all : attempt to remove all files within /local directories regardless of ownership (by default only the USER(${USER})'s files are removed)
  --ssh-dryrun : print list of files to be deleted over SSH into ~/${script_name}_<timestamp>_removed_files.txt log file without actually deleting
  --dryrun : print actions without executing
EOM
if (( $# < 1 )); then
    echo_e "$script_usage"
    exit_script_with_status 1
fi


## Parse arguments
set +u
while (( "$#" )); do
    arg="$1"

    if ! [[ $arg == -* ]]; then

        if [ -z "$cleanup_mode" ]; then
            cleanup_mode="$arg"
        else
            echo_e "Unexpected argument: ${arg}"
            exit_script_with_status 1
        fi

    else
        arg_opt=$(echo "$arg" | sed -r 's|\-+(.*)|\1|')
        arg_opt_nargs=''
        arg_val_can_start_with_dash=false

        if [ "$arg_opt" = 'h' ] || [ "$arg_opt" = 'help' ]; then
            arg_opt_nargs=0
            echo "$script_usage"
            exit 0

        elif [ "$arg_opt" = 'ssh-pw' ]; then
            arg_opt_nargs=1
            ssh_passphrase="$2"

        elif [ "$arg_opt" = 'all' ]; then
            arg_opt_nargs=0
            remove_all=true

        elif [ "$arg_opt" = 'ssh-dryrun' ]; then
            arg_opt_nargs=0
            ssh_dryrun=true

        elif [ "$arg_opt" = 'dryrun' ]; then
            arg_opt_nargs=0
            dryrun=true

        else
            echo_e "Unexpected argument: ${arg}"
            exit_script_with_status 1
        fi

        if [ -z "$arg_opt_nargs" ]; then
            echo_e "Developer error! "'$arg_opt_nargs'" was not set for argument: ${arg}"
            exit_script_with_status 1
        fi

        for i in $(seq 1 $arg_opt_nargs); do
            shift
            arg_val="$1"
            if [ "$arg_val_can_start_with_dash" = false ] && [[ $arg_val == -* ]]; then
                echo_e "Unexpected argument value: ${arg} ${arg_val}"
                exit_script_with_status 1
            fi
        done
    fi

    shift
done
set -u


## Validate arguments

if (( $(indexOf "$cleanup_mode" "${cleanup_mode_choices_arr[@]}") == -1 )); then
    echo_e "Rounding mode must be one of the following: ${cleanup_mode_choices_arr[*]}"
    exit_script_with_status 1
fi
if [ "$cleanup_mode" = 'ssh' ]; then
    use_ssh=true
fi


log_date=$(date +'%Y%m%d%H%M%S')

qsubscript=$(cat <<EOF
#!/bin/bash

#PBS -N CleanupLocal
#PBS -m n
#PBS -k oe
#PBS -j oe

echo ________________________________________________________
echo
echo PBS Job Log
echo Start time: \$(date)
echo
echo Job name: \$PBS_JOBNAME
echo Job ID: \$PBS_JOBID
echo Submitted by user: \$USER
echo User effective group ID: \$(id -ng)
echo
echo Hostname of submission: \$PBS_O_HOST
echo Submitted to cluster: \$PBS_SERVER
echo Submitted to queue: \$PBS_QUEUE
echo Requested nodes per job: \$PBS_NUM_NODES
echo Requested cores per node: \$PBS_NUM_PPN
echo Requested cores per job: \$PBS_NP
echo Node list file: \$PBS_NODEFILE
echo Nodes assigned to job: \$(cat \$PBS_NODEFILE)
echo Running node index: \$PBS_O_NODENUM
echo
echo Running on hostname: \$HOSTNAME
echo Parent PID: \$PPID
echo Process PID: \$\$
echo
echo Working directory: \$PBS_O_WORKDIR
echo ________________________________________________________
echo

echo "Removed the following files:"

find /local/ -mindepth 1 -user ${USER} -ls -delete
EOF
)

nodelist=$(pbsnodes -l up | gawk '{print $1}' | sort)

for host in $nodelist ; do

    if [ "$use_ssh" = true ]; then

        cmd="ssh ${host} -f 'find /local -mindepth 1"

        if [ "$remove_all" = false ]; then
            cmd="${cmd} -user ${USER}"
        fi
        cmd="${cmd} -ls"

        if [ "$ssh_dryrun" = false ]; then
            cmd="${cmd} -delete"
        fi
        cmd="${cmd} >> ~/${script_name}_${log_date}_removed_files.txt'"

        if [ -n "$ssh_passphrase" ]; then
            cmd="expect -c \"spawn ${cmd}; expect 'passphrase'; send '${ssh_passphrase}\r'; interact\""
            cmd=$(echo "$cmd" | sed -r "s|'|\\\\\"|g")
        fi

        echo "$cmd"
        if [ "$dryrun" = false ]; then
            eval "$cmd"
        fi

    else
        ncpus=$(pbsnodes -a ${host} | grep np | gawk '{print $3}')
        echo "Host: ${host} -- ncpus: ${ncpus}"

        if [ "$dryrun" = true ]; then
            echo 'echo $qsubscript'" | qsub -l 'nodes=${host},ncpus=${ncpus}'"
        else
            echo "$qsubscript" | qsub -l "nodes=${host},ncpus=${ncpus}"
        fi
    fi

done
