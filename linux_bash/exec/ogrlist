#!/bin/bash

## Bash settings
set -uo pipefail

## Script globals
script_file=$(readlink -f "${BASH_SOURCE[0]}"); export CURRENT_PARENT_BASH_SCRIPT_FILE="$script_file"
script_dir=$(dirname "$script_file")
script_name=$(basename "$script_file")
script_args=("$@")

## Script imports
lib_dir="${script_dir}/../lib"
bash_functions_script="${lib_dir}/bash_script_func.sh"

## Source imports
source "$bash_functions_script"


## Arguments
dbase_path=''
layer_name=''
field_name=''
delimiter=','
print_header=false
debug=false

## Custom globals


## Script usage
read -r -d '' script_usage << EOM
Usage: ${script_name} [DBASE] [OPTION]...

List information from a Shapefile or FileGDB database,
leveraging the GDAL/OGR 'ogrinfo' command.

If no options are provided, layer names are listed for
FileGDB DBASE, or field names are listed for Shapefile DBASE.
If layer name option is provided, field names in that layer
are listed.
If layer and field name options are provided, the values of
all records for that field in that layer are listed.

Options:
 -l,--layer
        Name of feature class layer in DBASE.
        (Most Shapefiles only have one layer, and the script
         will assume the layer name is the same as the
         Shapefile name if this option is not provided.)
 -f,--field
        Name of field(s) in feature class (indicated by --layer
        option) from which values are listed.
        Values from multiple fields can be listed by providing
        a comma-separated string of field names.
 -d,--delim (default='${delimiter}')
        Delimiting character (or string) separating returned
        values when multiple fields are listed.
 -H,--header
        Print header line listing delimited field name(s)
        before printing list of field values.
        Useful when redirecting output to a CSV file.
-db,--debug
        Print 'ogrinfo' command used to extract information,
        without executing.
EOM
if (( $# < 1 )); then
    echo_e -e "$script_usage"
    exit_script_with_status 1
fi


## Parse arguments
set +u
while (( "$#" )); do
    arg="$1"

    if [ "$(string_startswith "$arg" '-')" = false ]; then
        if [ -z "$dbase_path" ]; then
            dbase_path="$arg"
        else
            echo_e "Unexpected argument: ${arg}"
            exit_script_with_status 1
        fi

    else
        arg_opt="$(string_lstrip "$arg" '-')"
        arg_opt_nargs=''
        if [ "$(string_contains "$arg_opt" '=')" = true ]; then
            arg_val="${arg_opt#*=}"
            arg_opt="${arg_opt%%=*}"
            arg_opt_nargs_do_shift=false
        else
            arg_val="$2"
            arg_opt_nargs_do_shift=true
        fi
        arg_val_can_start_with_dash=false

        if [ "$arg_opt" = 'h' ] || [ "$arg_opt" = 'help' ]; then
            arg_opt_nargs=0
            echo "$script_usage"
            exit 0

        elif [ "$arg_opt" = 'l' ] || [ "$arg_opt" = 'layer' ]; then
            arg_opt_nargs=1
            layer_name="$arg_val"

        elif [ "$arg_opt" = 'f' ] || [ "$arg_opt" = 'field' ]; then
            arg_opt_nargs=1
            field_name="$arg_val"

        elif [ "$arg_opt" = 'd' ] || [ "$arg_opt" = 'delim' ]; then
            arg_opt_nargs=1
            delimiter="$arg_val"

        elif [ "$arg_opt" = 'H' ] || [ "$arg_opt" = 'header' ]; then
            arg_opt_nargs=0
            print_header=true

        elif [ "$arg_opt" = 'db' ] || [ "$arg_opt" = 'debug' ]; then
            arg_opt_nargs=0
            debug=true

        else
            arg_opt_nargs=0

            if [ "$(re_test '^d.$' "$arg_opt")" == "true" ]; then
                delimiter="${arg_opt/d/}"

            else
                echo_e "Unexpected argument: ${arg}"
                exit_script_with_status 1
            fi
        fi

        if [ -z "$arg_opt_nargs" ]; then
            echo_e "Developer error! "'$arg_opt_nargs'" was not set for argument: ${arg}"
            exit_script_with_status 1
        fi

        if [ "$arg_opt_nargs_do_shift" = true ]; then
            for arg_num in $(seq 1 $arg_opt_nargs); do
                shift
                arg_val="$1"
                if [ -z "$arg_val" ]; then
                    echo_e "Missing expected value (#${arg_num}) for argument: ${arg}"
                    exit_script_with_status 1
                elif [ "$arg_val_can_start_with_dash" = false ] && [ "$(string_startswith "$arg_val" '-')" = true ]; then
                    echo_e "Unexpected argument value: ${arg} ${arg_val}"
                    exit_script_with_status 1
                fi
            done
        fi
    fi

    shift
done
set -u


## Validate arguments

if [ -z "$dbase_path" ]; then
    echo_e "DBASE argument must be provided"
    exit_script_with_status 1
fi
if [ ! -e "$dbase_path" ]; then
    echo_e "DBASE file/folder does not exist: ${dbase_path}"
    exit_script_with_status 1
fi


## Adjust arguments

if [ -z "$layer_name" ] && [ "$(string_endswith "$dbase_path" '.shp')" = true ]; then
    # Assume layer name is the same as the filename (works for most shapefiles)
    layer_name=$(basename "$dbase_path")
    layer_name="${layer_name%.*}"
fi


## Main program

if [ -z "$layer_name" ]; then
    cmd="ogrinfo -so -al '${dbase_path}' | grep '^Layer name:'"
elif [ -z "$field_name" ]; then
    cmd="ogrinfo -so -al '${dbase_path}' | sed -n '/^Layer name: ${layer_name}/,\${p;/^[[:space:]]*\$/q}' | grep -E '^[^[:space:]]+\: [^[:space:]]+ \([0-9]+\.?[0-9]*\)$'"
else
    awk_cmd='BEGIN { csv="" } { val=$0; if (val=="") { if (csv!="") print csv; csv=""; } else if (csv=="") { csv=val; } else { csv=sprintf("%s'"${delimiter}"'%s", csv, val); } } END { if (csv!="") print csv; }'
    cmd="ogrinfo -dialect sqlite -sql 'SELECT ${field_name} FROM ${layer_name}' '${dbase_path}' | sed -e '1,/OGRFeature(SELECT):0/d' | grep -E '(^$| = )' | cut -d'=' -f2- | cut -d' ' -f2- | awk '${awk_cmd}'"
    if [ "$print_header" = true ]; then
        cmd="echo '${field_name//,/${delimiter}}' ; ${cmd}"
    fi
fi

if [ "$debug" = true ]; then
    echo "$cmd"
else
    eval "$cmd"
fi
