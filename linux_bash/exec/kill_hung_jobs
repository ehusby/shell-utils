#!/bin/bash

## Bash settings
set -uo pipefail

## Script globals
script_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$({ cd "$(dirname "${BASH_SOURCE[0]}")" || { echo "Failed to access script file directory" >&2; exit; } } && pwd)
script_dir_abs=$({ cd "$(dirname "${BASH_SOURCE[0]}")" || { echo "Failed to access script file directory" >&2; exit; } } && pwd -P)
script_file="${script_dir}/${script_name}"
if [ -L "${BASH_SOURCE[0]}" ]; then
    script_file_abs=$(readlink "${BASH_SOURCE[0]}")
else
    script_file_abs="${script_dir_abs}/${script_name}"
fi
export CURRENT_PARENT_BASH_SCRIPT_FILE="$script_file"
script_args=("$@")

## Script imports
lib_dir="${script_dir}/../lib"
bash_functions_script="${lib_dir}/bash_script_func.sh"

## Source imports
source "$bash_functions_script"


## Arguments
mmin_thresh="$1"
check_min=5
jobname_prefix=''


## Script usage
if [ "$#" -lt 2 -o "$#" -gt 3 ]; then
    echo "Script requires 2 arguments + 1 optional: mmin_thresh, check_min, [jobname_prefix]"
    echo "    mmin_thresh      - number of minutes since ~/<jobname>.o<jobnum> job output log file was last modified at which point the job is deemed 'hung'"
    echo "    check_min        - time interval between checks of 'qstat -r -n1 -u ${USER}' for hung jobs"
    echo "    [jobname_prefix] - only check running jobs matching this jobname prefix"
    exit 1
fi

mmin_thresh="$1"
check_min="$2"
jobname_prefix=''
if [ "$#" -ge 3 ]; then
    jobname_prefix="$3"
fi

hungjobs_stash_dir="${HOME}/scratch/hungjobs_outfiles/"
hungjobs_digest="${HOME}/scratch/hungjobs_digest.txt"

if [ ! -d "${hungjobs_stash_dir}" ]; then
    mkdir -p "${hungjobs_stash_dir}"
fi

while true; do
    while read -r qstat_row; do
        qstat_cols=($qstat_row)
        jobnum=$(echo "${qstat_cols[0]}" | cut -d"." -f1)
        jobxml=$(qstat -xlf "$jobnum")
        jobname=$(echo "$jobxml" | parse_xml_value 'Job_Name')

        if [[ "${jobname}" != "${jobname_prefix}"* ]]; then continue; fi

        outfile=$(echo "$jobxml" | parse_xml_value 'Output_Path')
        outfile=$(echo "$outfile" | rev | cut -d":" -f1 | rev)

        # Job output logs on Nunatak are forced into the home dir
        outfname=$(basename "$outfile")
        outfile="${HOME}/${outfname}"

        inactive_outfile=$(find "$outfile" -mmin +${mmin_thresh})

        if [ -n "$inactive_outfile" ]; then
            outfile_mtime_sec=$(date +%s -r "$inactive_outfile")
            current_time_sec=$(date +%s)
            inactive_sec=$((current_time_sec - outfile_mtime_sec))
            inactive_hms=$(sec2hms "$inactive_sec")

            log "Deleting hung job with outfile last modified ${inactive_hms} ago (mmin_thresh=${mmin_thresh}):\n${qstat_row}" | tee -a "$hungjobs_digest"
            qdel "$jobnum"
            cp "$inactive_outfile" "$hungjobs_stash_dir"
        fi

    done < <( qstat -r -n1 -u "$USER" | tail -n +6 )

    for (( min_til_check=${check_min}; min_til_check > 0; min_til_check-- )); do
        echo -en "\r${min_til_check} minutes until next check for hung jobs (mmin_thresh=${mmin_thresh}, check_min=${check_min}, jobname_prefix='${jobname_prefix}')"
        sleep 1m
    done
    echo -en "\r"
done
