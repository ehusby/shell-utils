# .bashrc

# >>> CHANGE NAME OF YOUR EXISTING SYSTEM-PROVIDED .bashrc FILE
# >>> to '.bashrc_system_default', and this .bashrc will source that!!
if [ -e "${HOME}/.bashrc_system_default" ]; then
    source "${HOME}/.bashrc_system_default"
fi

### Source global definitions
#if [ -f /etc/bashrc ]; then
#    . /etc/bashrc
#fi


## Set umask to enable rwx for group members
#umask 002  # allow OTHER read and execute perms, but not write
umask 007  # disallow OTHER read|write|execute perms

### Settings for interactive shells only
if [ -n "$PS1" ]; then

    # Overwrite possibly goofy system default for command prompt
    # that messes with screen window names
    export PS1='[\u@\h:\w]\$ '
    export PROMPT_COMMAND=''

    # Append trailing slash when tab-completing directory paths
    bind 'set mark-symlinked-directories on'

    # Disable default CTRL+S mapping as XON/XOFF flow control
    # ... you usually don't need it?
    # Then you can use both CTRL+R and CTRL+S to search
    # backwards and forwards through your history!!
    # AND you don't accidentally freeze your screen with CTRL+S
    stty -ixon

fi


################################
### System-specific settings ###
################################

## Exports (PATH changes and global vars)
# >>> FILL OUT OR COMMENT OUT THE FOLLOWING LINES <<< #
SHELL_UTILS_PATH="<path-to>/shell-utils"  # Necessary for sourcing general purpose shell functions
export MY_EMAIL="<your-email-address>"  # Necessary for shell-utils 'email_me' script
export PATH="${PATH}:${SHELL_UTILS_PATH}/linux_bash/exec"  # Easily call shell-utils executable scripts
#export PATH="${PATH}:<path-to>/pyscript-utils"  # Easily call pyscript-utils executable scripts

## Aliases

## Functions

################################
################################


### General purpose functions and aliases

### Source general purpose shell functions from library script
#if ! [ -z ${SHELL_UTILS_PATH+x} ] && [ -n "$SHELL_UTILS_PATH" ]; then
#    source "${SHELL_UTILS_PATH}/linux_bash/lib/bash_shell_func.sh"
#fi


## String manipulation

function line2space() { tr '\n' ' ' < /dev/stdin; }
function space2line() { tr ' ' '\n' < /dev/stdin; }

function strrep() { sed -r "s|${1}|${2}|g" < /dev/stdin; }
function strcat() { sed -r "s|(.*)|\1${1}|" < /dev/stdin; }


## Path representation

function fullpath() {
    local dirent_arr
    if (( $# > 0 )); then
        dirent_arr=("$@")
    else
        dirent_arr=(*)
    fi
    for dirent in "${dirent_arr[@]}"; do
        readlink -f "$dirent"
    done
}
function basename_all() {
    local dirent_arr
    if (( $# > 0 )); then
        dirent_arr=("$@")
    else
        dirent_arr=(*)
    fi
    for dirent in "${dirent_arr[@]}"; do
        basename "$dirent"
    done
}
function dirname_all() {
    local dirent_arr
    if (( $# > 0 )); then
        dirent_arr=("$@")
    else
        dirent_arr=(*)
    fi
    for dirent in "${dirent_arr[@]}"; do
        dirname "$dirent"
    done
}


## File operations

function absymlink() {
    local cmd_arr arg cmd
    cmd_arr=()
    while (( "$#" )); do
        arg="$1"
        if ! [[ $arg == -* ]]; then
            arg=$(readlink -f "$arg")
        fi
        cmd_arr+=( "$arg" )
        shift
    done
    cmd=$(echo "ln -s ${cmd_arr[*]}")
    eval "$cmd"
}


## File interrogation

function count_by_date() {
    grep -Eo '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+[0-9]+' | awk '{date_count_dict[$0]++} END {for (date in date_count_dict) printf "%s : %5s\n", date, date_count_dict[date]}' | sort < /dev/stdin
}
function count_by_month() {
    grep -Eo '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+[0-9]+' | awk '{date_count_dict[$1]++} END {for (date in date_count_dict) printf "%s : %5s\n", date, date_count_dict[date]}' | sort < /dev/stdin
}
function count_by_date_with_ex() {
    grep -Eo '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+[0-9]+.*$' | awk '{date=sprintf("%s %2s", $1, $2); date_count_dict[date]++; date_ex_dict[date]=$0} END {for (date in date_count_dict) printf "%s : %5s : %s\n", date, date_count_dict[date], date_ex_dict[date]}' | sort < /dev/stdin
}
function count_by_month_with_ex() {
    grep -Eo '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+[0-9]+.*$' | awk '{date=$1; date_count_dict[date]++; date_ex_dict[date]=$0} END {for (date in date_count_dict) printf "%s : %5s : %s\n", date, date_count_dict[date], date_ex_dict[date]}' | sort < /dev/stdin
}


## File modification

function touch_all() {
    echo "Will recursively search through argument directories and touch all files within"
    if (( $# == 0 )); then
        echo "Usage: touch_all path1 path2 ... pathN"
        return
    fi
    while (( $# > 0 )); do
        echo "Touching files in: ${1}"
        find "$1" -type f -exec touch {} \;
        shift
    done
    echo "Done!"
}

function fix_perms() {
    echo "Will give full RWX perms to USER & GROUP, and remove RWX perms from OTHER"
    if (( $# == 0 )); then
        echo "Usage: fix_perms path1 path2 ... pathN"
        return
    fi
    while (( $# > 0 )); do
        echo "Fixing perms in: ${1}"
        chmod -R u=rwX,g=rwX,o-rwx "$1"
        shift
    done
    echo "Done!"
}


## Git

function git_drop_all_changes() {
    git checkout -- .
}

function git_make_exec() {
    chmod -x $*
    git -c core.fileMode=false update-index --chmod=+x $*
    chmod +x $*
}

function git_cmd_in() {
    local cmd_name
    local ssh_passphrase no_ssh_passphrase
    local start_dir repo_dir_arr repo_dir repo_name

    cmd_name='cmd'
    if [ -n "$1" ]; then
        cmd_name="$1"; shift
    fi
    if (( $# == 0 )); then
        echo "Usage: git_${cmd_name}_in [-p ssh_passphrase] <repo-root-dir> ..."
        return
    fi

    ssh_passphrase=''
    no_ssh_passphrase=false
    if [ "$1" == '--no-ssh-passphrase' ]; then
        no_ssh_passphrase=true; shift
    fi
    if [ "$1" == '-p' ]; then
        shift; if [ "$no_ssh_passphrase" == "false" ]; then ssh_passphrase="$1"; fi; shift
    fi

    start_dir=$(pwd)
    repo_dir_arr=($(fullpath $*))
    for repo_dir in "${repo_dir_arr[@]}"; do
        echo -e "\nChanging to repo dir: ${repo_dir}"
        cd "$repo_dir" || return
        repo_name=$(basename "$repo_dir")

        echo "'${repo_name}' results of 'git ${cmd_name}' command:"
        if [ -n "$ssh_passphrase" ]; then
            expect -c "spawn git ${cmd_name}; expect \"passphrase\"; send \"${ssh_passphrase}\r\"; interact"
        else
            git -c pager.branch=false ${cmd_name}
        fi

        shift
    done

    echo -e "\nChanging back to starting dir: ${start_dir}"
    cd "$start_dir" || return
    echo "Done!"
}

function git_branch_in() {
    git_cmd_in branch '--no-ssh-passphrase' $*
}
function git_pull_in() {
    git_cmd_in pull $*
}

function git_clone_replace() {
    local repo_url repo_url_bname repo_name
    local cmd status

    if (( $# == 0 )); then
        echo "Usage: git_clone_replace <github-repo-url>"
        return
    fi

    repo_url="$1"
    repo_url_bname=$(basename "$repo_url")
    repo_name="${repo_url_bname/.git/}"
    if [ ! -e "${repo_name}" ]; then
        echo "ERROR: Current repo folder does not exist: ${repo_name}"
        return
    fi
    if [ -e "${repo_name}_old" ]; then
        echo "ERROR: Old repo folder still exists: ${repo_name}_old"
        return
    fi
    if [ -e "${repo_name}_new" ]; then
        echo "ERROR: New repo folder already exists: ${repo_name}_new"
        return
    fi

    cmd="git clone ${repo_url} ${repo_name}_new"
    echo -e "\nCOMMAND: ${cmd}"; eval "$cmd"

    cmd="mv ${repo_name} ${repo_name}_old; mv ${repo_name}_new ${repo_name};"
    echo -e "\nCOMMAND: ${cmd}\n(sleeping 3 seconds...)"; sleep 5s; eval "$cmd"
    status=$?
    if (( status == 0 )); then
        cmd="rm -rf ${repo_name}_old"
        echo -e "\nCOMMAND: ${cmd}\n(sleeping 5 seconds...)"; sleep 5s; eval "$cmd"
    fi

    echo -e "\nDone!"
}


## Other

function layz() {
    local cmd_arr_in cmd_arr_out
    local arg_idx rep_idx
    local arg_out arg_rep
    local cmd_out debug arg_opt
    debug=false
    if [[ $1 == -* ]]; then
        arg_opt=$(echo "$1" | sed -r 's|\-+(.*)|\1|')
        if [ "$arg_opt" == 'dryrun' ] || [ "$arg_opt" == 'debug' ]; then
            debug=true
            shift
        fi
    fi
    cmd_arr_in=("$@")
    cmd_arr_out=()
    for arg_idx in "${!cmd_arr_in[@]}"; do
        arg_out="${cmd_arr_in[$arg_idx]}"
        for rep_idx in "${!cmd_arr_in[@]}"; do
            if (( rep_idx < arg_idx )); then
                arg_rep="${cmd_arr_out[$rep_idx]}"
            else
                arg_rep="${cmd_arr_in[$rep_idx]}"
            fi
            arg_out=$(echo "$arg_out" | sed -r "s|%${rep_idx}([^0-9]\|$)|${arg_rep}\1|g")
        done
        cmd_arr_out+=( "$arg_out" )
    done
    cmd_out="${cmd_arr_out[*]}"
    if [ "$debug" == "true" ]; then
        echo "$cmd_out"
    else
        $cmd_out
    fi
}

